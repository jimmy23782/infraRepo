AWSTemplateFormatVersion: '2010-09-09'
Description: Minimal Argo CD bootstrap onto existing EKS via CodeBuild + Lambda (no local kubectl).

Parameters:
  ClusterName:
    Type: String
    Description: Existing EKS cluster name (e.g., demo-eks-dev)
  Region:
    Type: String
    Default: ap-southeast-2
  KubernetesNamespace:
    Type: String
    Default: argocd
  ExposeServerAsLB:
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"
    Description: If true, patch argocd-server to type=LoadBalancer
  SSMParamPrefix:
    Type: String
    Default: /eks
    Description: SSM prefix where outputs are stored (e.g., /eks/<cluster>/argocd/*)

  GitOpsRepoUrl:
    Type: String
    Description: Git repo URL for app-of-apps (e.g., https://github.com/jimmy23782/GitOpsRepo.git)
  GitOpsBranch:
    Type: String
    Default: feature/setuphelmcharts   # <- set to your feature branch (optional; you also pass this in workflow)
  GitOpsRootPath:
    Type: String
    Default: gitopsRepo/argo/apps
    Description: Path in repo that holds child apps (app-of-apps)
  RunToken:
    Type: String
    Default: ""
    Description: Change this (e.g., to a timestamp/commit SHA) to re-run the bootstrap CodeBuild.

Resources:

  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
      Policies:
        - PolicyName: ArgoBootstrapPerms
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [ eks:DescribeCluster ]
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:DescribeVpcs
                  - ec2:DescribeSubnets
                  - ec2:DescribeSecurityGroups
                Resource: "*"
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                  - ssm:AddTagsToResource
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource: "*"

  ArgoBootstrapProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "argocd-bootstrap-${ClusterName}"
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      TimeoutInMinutes: 30
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: false
        EnvironmentVariables:
          - Name: CLUSTER_NAME
            Value: !Ref ClusterName
          - Name: AWS_DEFAULT_REGION
            Value: !Ref Region
          - Name: K8S_NS
            Value: !Ref KubernetesNamespace
          - Name: EXPOSE_LB
            Value: !Ref ExposeServerAsLB
          - Name: PARAM_PREFIX
            Value: !Ref SSMParamPrefix
          - Name: GITOPS_REPO_URL
            Value: !Ref GitOpsRepoUrl
          - Name: GITOPS_BRANCH
            Value: !Ref GitOpsBranch
          - Name: GITOPS_ROOT_PATH
            Value: !Ref GitOpsRootPath
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub "/aws/codebuild/argocd-bootstrap-${ClusterName}"
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          env:
            shell: bash
          phases:
            install:
              commands:
                - set -euo pipefail
                - KVER=1.30.0
                - echo "Downloading kubectl v${KVER}..."
                - curl -sLo kubectl "https://dl.k8s.io/release/v${KVER}/bin/linux/amd64/kubectl"
                - echo "Verifying kubectl checksum..."
                - curl -sL "https://dl.k8s.io/release/v${KVER}/bin/linux/amd64/kubectl.sha256" -o kubectl.sha256
                - echo "$(cat kubectl.sha256)  kubectl" | sha256sum -c -
                - chmod +x kubectl && mv kubectl /usr/local/bin/
                - kubectl version --client --output=yaml | sed -n '1,6p'
                - echo "Configure kubeconfig"
                - aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_DEFAULT_REGION"
            pre_build:
              commands:
                - set -euo pipefail
                - echo "Wait for API server..."
                - |
                  for i in {1..30}; do
                    if kubectl version --request-timeout=10s >/dev/null 2>&1; then
                      echo "API OK"; break
                    fi
                    echo "API not ready yet... ($i/30)"; sleep 5
                  done
                - echo "Wait for at least 1 Ready node..."
                - |
                  for i in {1..60}; do
                    READY=$(kubectl get nodes --no-headers 2>/dev/null | awk '$2=="Ready"{c++} END{print c+0}')
                    if [ "${READY:-0}" -ge 1 ]; then
                      echo "Found ${READY} Ready node(s)."
                      kubectl get nodes -o wide
                      break
                    fi
                    echo "No Ready nodes yet... ($i/60)"; sleep 10
                  done
            build:
              commands:
                - set -euo pipefail
                - echo "Create namespace if not exists"
                - kubectl create namespace "$K8S_NS" || true
                - echo "Install Argo CD (official manifests)"
                - kubectl apply -n "$K8S_NS" -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
                - echo "Wait for Argo CD server deployment to become available (up to 15 minutes)"
                - |
                  ok=false
                  for i in {1..30}; do
                    if kubectl -n "$K8S_NS" rollout status deploy/argocd-server --timeout=30s; then
                      echo "Argo CD server is ready"; ok=true; break
                    else
                      echo "Argo CD server not ready yet... retrying ($i/30)"
                      kubectl -n "$K8S_NS" get pods -owide || true
                      sleep 30
                    fi
                  done
                  $ok || { echo "argocd-server did not become ready in time"; exit 1; }
                - |
                  if [ "$EXPOSE_LB" = "true" ]; then
                    echo "Patch argocd-server Service to type=LoadBalancer"
                    kubectl -n "$K8S_NS" patch svc argocd-server -p '{"spec":{"type":"LoadBalancer"}}' || true
                  fi
                # --- create/refresh app-of-apps pointing to your GitOps repo/branch/path ---
                - |
                  echo "Applying app-of-apps (repo=$GITOPS_REPO_URL, branch=$GITOPS_BRANCH, path=$GITOPS_ROOT_PATH)"
                  cat <<EOF | kubectl apply -f -
                  apiVersion: argoproj.io/v1alpha1
                  kind: Application
                  metadata:
                    name: bootstrap-apps
                    namespace: ${K8S_NS}
                  spec:
                    project: default
                    source:
                      repoURL: ${GITOPS_REPO_URL}
                      targetRevision: ${GITOPS_BRANCH}
                      path: ${GITOPS_ROOT_PATH}
                    destination:
                      server: https://kubernetes.default.svc
                      namespace: ${K8S_NS}
                    syncPolicy:
                      automated:
                        prune: true
                        selfHeal: true
                      syncOptions:
                        - CreateNamespace=true
                  EOF
                - echo "Force-refresh app-of-apps to trigger reconciliation"
                - kubectl -n "$K8S_NS" patch application bootstrap-apps --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}' || true
                - kubectl get applications.argoproj.io -A -o wide || true

  CodeBuildClusterAdminAccess:
    Type: AWS::EKS::AccessEntry
    Properties:
      ClusterName: !Ref ClusterName
      PrincipalArn: !GetAtt CodeBuildServiceRole.Arn
      AccessPolicies:
        - AccessScope:
            Type: cluster
          PolicyArn: arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy

  # ---- Lambda (custom resource) to start CodeBuild & wait ----
  TriggerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildInvoke
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: "*"

  TriggerFn:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt TriggerRole.Arn
      Timeout: 900
      Code:
        ZipFile: |
          import json, time, urllib.request, boto3, traceback
          cb = boto3.client('codebuild')
          def respond(event, status, data=None, reason=None):
              body = {'Status': status,
                      'Reason': reason or 'See CloudWatch Logs',
                      'PhysicalResourceId': event.get('PhysicalResourceId','ArgoBootstrap'),
                      'StackId': event['StackId'],
                      'RequestId': event['RequestId'],
                      'LogicalResourceId': event['LogicalResourceId'],
                      'Data': data or {}}
              req = urllib.request.Request(event['ResponseURL'],
                                           data=json.dumps(body).encode(),
                                           method='PUT')
              req.add_header('content-type','')
              urllib.request.urlopen(req)

          def handler(event, context):
              try:
                  req_type = event['RequestType']
                  proj = event['ResourceProperties']['ProjectName']
                  if req_type in ['Create','Update']:
                      r = cb.start_build(projectName=proj)
                      bid = r['build']['id']
                      status = None
                      while True:
                          time.sleep(8)
                          b = cb.batch_get_builds(ids=[bid])['builds'][0]
                          status = b.get('buildStatus')
                          if status in ['SUCCEEDED','FAILED','FAULT','STOPPED','TIMED_OUT']:
                              break
                      data = {'BuildId': bid}
                      logs = b.get('logs') or {}
                      if logs.get('groupName'):  data['LogGroup'] = logs['groupName']
                      if logs.get('streamName'): data['LogStream'] = logs['streamName']
                      if status == 'SUCCEEDED':
                          respond(event, 'SUCCESS', data=data)
                      else:
                          reason = f"CodeBuild status: {status}"
                          phases = b.get('phases', [])
                          for p in reversed(phases):
                              if p.get('phaseStatus') == 'FAILED' and p.get('contexts'):
                                  msg = p['contexts'][0].get('message')
                                  if msg:
                                      reason = f"{reason} | {p.get('phase')}: {msg}"
                                      break
                          respond(event, 'FAILED', data=data, reason=reason)
                  else:
                      respond(event, 'SUCCESS', {'Message': 'No action on Delete'})
              except Exception as e:
                  traceback.print_exc()
                  respond(event, 'FAILED', reason=str(e))

  ArgoInstall:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - CodeBuildClusterAdminAccess
    Properties:
      ServiceToken: !GetAtt TriggerFn.Arn
      ProjectName: !Ref ArgoBootstrapProject
      RunToken: !Ref RunToken   # <— new, Lambda ignores it, CFN uses it to detect change

Outputs:
  ArgoCDNamespace:
    Value: !Ref KubernetesNamespace