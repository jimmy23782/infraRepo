name: cfn-plan-apply

on:
  pull_request:
    paths:
      - "cloudformation/**"
      - ".github/workflows/cfn-plan-apply.yml"
  push:
    branches: ["main"]
    paths:
      - "cloudformation/**"
      - ".github/workflows/cfn-plan-apply.yml"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  AWS_REGION: ap-southeast-2
  ENV: dev
  PREFIX: demo-eks
  VPC_STACK: demo-eks-vpc-dev
  EKS_STACK: demo-eks-eks-dev
  NG_STACK: demo-eks-nodegroup-dev
  ARGO_STACK: demo-eks-argocd-dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::685801731369:role/github-oidc-deployer
          aws-region: ${{ env.AWS_REGION }}

      - name: Set AWS CLI behavior
        run: |
          echo "AWS_PAGER=" >> $GITHUB_ENV
          echo "AWS_RETRY_MODE=standard" >> $GITHUB_ENV
          echo "AWS_MAX_ATTEMPTS=2" >> $GITHUB_ENV

      - name: Validate CFN templates
        run: |
          aws cloudformation validate-template --template-body file://cloudformation/vpc.yaml
          aws cloudformation validate-template --template-body file://cloudformation/eks-cluster.yaml
          aws cloudformation validate-template --template-body file://cloudformation/nodegroup.yaml
          aws cloudformation validate-template --template-body file://cloudformation/argocd-bootstrap.yaml

      # ---------- PREFLIGHT: VPC ----------
      - name: Preflight - wait if VPC stack is IN_PROGRESS
        run: |
          set -e
          STATUS=$(aws cloudformation describe-stacks --stack-name "${VPC_STACK}" \
            --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")
          echo "VPC stack status: $STATUS"
          case "$STATUS" in
            CREATE_IN_PROGRESS) aws cloudformation wait stack-create-complete --stack-name "${VPC_STACK}" ;;
            UPDATE_IN_PROGRESS|UPDATE_COMPLETE_CLEANUP_IN_PROGRESS) aws cloudformation wait stack-update-complete --stack-name "${VPC_STACK}" ;;
            DELETE_IN_PROGRESS) aws cloudformation wait stack-delete-complete --stack-name "${VPC_STACK}" ;;
            *) echo "No wait needed." ;;
          esac

      # ---------- VPC ----------
      - name: Create/Update VPC stack
        run: |
          aws cloudformation deploy \
            --template-file cloudformation/vpc.yaml \
            --stack-name "${VPC_STACK}" \
            --parameter-overrides file://cloudformation/parameters/${ENV}/vpc.json \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Get VPC outputs
        id: vpc
        run: |
          set -euo pipefail
          VAL=$(aws cloudformation describe-stacks --stack-name "${VPC_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='PublicSubnetIds'].OutputValue | [0]" \
            --output text)
          echo "Resolved PublicSubnetIds from ${VPC_STACK}: $VAL"
          VAL_CLEAN=$(echo "$VAL" | tr -d '[:space:]')
          if [ -z "$VAL_CLEAN" ] || [ "$VAL_CLEAN" = "None" ]; then
            echo "ERROR: Output 'PublicSubnetIds' is missing/empty on stack ${VPC_STACK}" >&2
            aws cloudformation describe-stacks --stack-name "${VPC_STACK}" \
              --query "Stacks[0].Outputs" --output table || true
            exit 1
          fi
          echo "public_subnets=$VAL_CLEAN" >> "$GITHUB_OUTPUT"

      # ---------- PREFLIGHT: EKS ----------
      - name: Preflight - heal/delete stuck EKS stack
        run: |
          set -euo pipefail
          STACK="${EKS_STACK}"
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")
          echo "EKS stack status: $STATUS"
          if [[ "$STATUS" == "ROLLBACK_FAILED" || "$STATUS" == "ROLLBACK_COMPLETE" || "$STATUS" == "DELETE_FAILED" ]]; then
            aws cloudformation delete-stack --stack-name "$STACK" || true
            if ! aws cloudformation wait stack-delete-complete --stack-name "$STACK"; then
              mapfile -t FAILS < <(
                aws cloudformation describe-stack-events --stack-name "$STACK" --max-items 200 \
                  --query "reverse(StackEvents)[?contains(ResourceStatus,'DELETE_FAILED')].[LogicalResourceId]" \
                  --output text | awk '!seen[$0]++'
              )
              [[ ${#FAILS[@]} -gt 0 ]] && aws cloudformation delete-stack --stack-name "$STACK" --retain-resources ${FAILS[*]} || true
              aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
            fi
          fi

      - name: Create/Update EKS cluster
        run: |
          PARAMS=$(jq -r '.Parameters | to_entries[] | "\(.key)=\(.value)"' cloudformation/parameters/${ENV}/eks.json)
          aws cloudformation deploy \
            --template-file cloudformation/eks-cluster.yaml \
            --stack-name "${EKS_STACK}" \
            --parameter-overrides $PARAMS PublicSubnetIds="${{ steps.vpc.outputs.public_subnets }}" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Wait for EKS to be ACTIVE
        run: |
          CLUSTER=$(aws cloudformation describe-stacks --stack-name "${EKS_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" --output text)
          aws eks wait cluster-active --name "$CLUSTER"

      # ---------- PREFLIGHT: ArgoCD ----------
      - name: Preflight - heal/delete stuck ArgoCD stack
        run: |
          set -euo pipefail
          STACK="${ARGO_STACK}"
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")
          echo "ArgoCD stack status: $STATUS"
          if [[ "$STATUS" == "ROLLBACK_FAILED" || "$STATUS" == "ROLLBACK_COMPLETE" || "$STATUS" == "DELETE_FAILED" ]]; then
            echo "Attempting delete of $STACK ..."
            aws cloudformation delete-stack --stack-name "$STACK" || true
            if ! aws cloudformation wait stack-delete-complete --stack-name "$STACK"; then
              echo "Delete failed; retaining blockers..."
              mapfile -t FAILS < <(
                aws cloudformation describe-stack-events --stack-name "$STACK" --max-items 200 \
                  --query "reverse(StackEvents)[?contains(ResourceStatus,'DELETE_FAILED')].[LogicalResourceId]" \
                  --output text | awk '!seen[$0]++'
              )
              echo "Retaining: ${FAILS[*]:-<none>}"
              if [[ "${#FAILS[@]}" -gt 0 ]]; then
                aws cloudformation delete-stack --stack-name "$STACK" --retain-resources ${FAILS[*]} || true
                aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
              fi
            fi
          else
            echo "No preflight action needed."
          fi

      - name: Ensure EKS access API is enabled (required for AccessEntry)
        run: |
          set -euo pipefail
          CLUSTER=$(aws cloudformation describe-stacks --stack-name "${EKS_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" --output text)
          MODE=$(aws eks describe-cluster --name "$CLUSTER" \
            --query 'cluster.accessConfig.authenticationMode' --output text 2>/dev/null || echo "UNKNOWN")
          echo "Current auth mode: $MODE"
          if [ "$MODE" != "API" ] && [ "$MODE" != "API_AND_CONFIG_MAP" ]; then
            echo "Updating cluster auth mode to API_AND_CONFIG_MAPâ€¦"
            aws eks update-cluster-config --name "$CLUSTER" \
              --access-config authenticationMode=API_AND_CONFIG_MAP
            aws eks wait cluster-active --name "$CLUSTER"
            aws eks describe-cluster --name "$CLUSTER" \
              --query 'cluster.accessConfig.authenticationMode' --output text
          else
            echo "Auth mode already OK."
          fi

      - name: Heal Argo stack DELETE_FAILED by removing stuck AccessEntry
        run: |
          set -euo pipefail
          STACK="${ARGO_STACK}"
          CLUSTER=$(aws cloudformation describe-stacks --stack-name "${EKS_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" --output text)
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")
          echo "Argo stack status: $STATUS"
          if [ "$STATUS" = "DELETE_FAILED" ] || [ "$STATUS" = "ROLLBACK_FAILED" ]; then
            echo "Trying to remove stuck EKS AccessEntry(s)..."
            for ROLE in $(aws iam list-roles --query "Roles[?starts_with(RoleName, 'demo-eks-argocd-dev-CodeBuildServiceRole')].RoleName" --output text); do
              ARN=$(aws iam get-role --role-name "$ROLE" --query 'Role.Arn' --output text || echo "")
              if [ -n "$ARN" ] && [ "$ARN" != "None" ]; then
                echo "Deleting access entry for principal: $ARN"
                aws eks delete-access-entry --cluster-name "$CLUSTER" --principal-arn "$ARN" || true
              fi
            done
            echo "Re-attempting stack delete..."
            aws cloudformation delete-stack --stack-name "$STACK" || true
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
          else
            echo "No heal needed."
          fi

      - name: Bootstrap Argo CD (CFN -> CodeBuild -> Argo install)
        run: |
          aws cloudformation deploy \
            --template-file cloudformation/argocd-bootstrap.yaml \
            --stack-name "${ARGO_STACK}" \
            --parameter-overrides \
              ClusterName=demo-eks-dev \
              Region=${{ env.AWS_REGION }} \
              KubernetesNamespace=argocd \
              ExposeServerAsLB=true \
              SSMParamPrefix=/eks/${{ env.ENV }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Show ArgoCD stack failure events (if any)
        if: failure()
        run: |
          aws cloudformation describe-stack-events --stack-name "${ARGO_STACK}" \
            --max-items 60 \
            --query "StackEvents[?ends_with(ResourceStatus,'FAILED')].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
            --output table || true

      - name: Show Lambda logs for Argo custom resource (auto-discover)
        if: failure()
        run: |
          set -euo pipefail
          REG="${AWS_REGION}"
          FN=$(aws cloudformation list-stack-resources \
            --region "$REG" \
            --stack-name "${ARGO_STACK}" \
            --query "StackResourceSummaries[?LogicalResourceId=='TriggerFn'].PhysicalResourceId | [0]" \
            --output text 2>/dev/null || echo "None")
          if [ -z "$FN" ] || [ "$FN" = "None" ]; then
            echo "No TriggerFn found in stack ${ARGO_STACK}."
            exit 0
          fi
          echo "Trigger function: $FN"
          LG="/aws/lambda/${FN}"
          LS=$(aws logs describe-log-streams \
            --region "$REG" \
            --log-group-name "$LG" \
            --order-by LastEventTime --descending --max-items 1 \
            --query 'logStreams[0].logStreamName' --output text 2>/dev/null || echo "None")
          if [ -z "$LS" ] || [ "$LS" = "None" ]; then
            echo "No CloudWatch log stream yet for $FN"
            exit 0
          fi
          echo "Log stream: $LS"
          echo "--- LAMBDA LOG (last 200 lines) ---"
          aws logs get-log-events --region "$REG" \
            --log-group-name "$LG" --log-stream-name "$LS" \
            --limit 10000 --output text | sed -E 's/^.*\t//' | tail -n 200

      - name: Show CodeBuild logs for Argo bootstrap (auto-discover)
        if: failure()
        run: |
          set -euo pipefail
          REG="${AWS_REGION}"
          PROJ=$(aws cloudformation list-stack-resources \
            --region "$REG" \
            --stack-name "${ARGO_STACK}" \
            --query "StackResourceSummaries[?ResourceType=='AWS::CodeBuild::Project'].PhysicalResourceId | [0]" \
            --output text 2>/dev/null || echo "None")
          if [ -z "$PROJ" ] || [ "$PROJ" = "None" ]; then
            echo "No CodeBuild project resource found in stack ${ARGO_STACK}."
            exit 0
          fi
          echo "Project: $PROJ"
          aws codebuild batch-get-projects --region "$REG" --names "$PROJ" \
            --query 'projects[0].{ServiceRole:serviceRole,Env:environment.environmentVariables}' --output table || true
          BID="None"
          for i in {1..5}; do
            BID=$(aws codebuild list-builds-for-project \
              --region "$REG" \
              --project-name "$PROJ" \
              --sort-order DESCENDING \
              --max-results 5 \
              --query 'ids[0]' \
              --output text 2>/dev/null || echo "None")
            if [ -n "$BID" ] && [ "$BID" != "None" ]; then break; fi
            echo "No builds yet; retrying... ($i/5)"; sleep 3
          done
          if [ -z "$BID" ] || [ "$BID" = "None" ]; then
            echo "No builds found for $PROJ"
            exit 0
          fi
          echo "Latest build: $BID"
          aws codebuild batch-get-builds --region "$REG" --ids "$BID" \
            --query 'builds[0].{Status:buildStatus,CurrentPhase:currentPhase,Image:environment.image,ServiceRole:serviceRole,Phases:phases,LogGroup:logs.groupName,LogStream:logs.streamName}' \
            --output table || true
          LG=$(aws codebuild batch-get-builds --region "$REG" --ids "$BID" --query 'builds[0].logs.groupName' --output text)
          LS=$(aws codebuild batch-get-builds --region "$REG" --ids "$BID" --query 'builds[0].logs.streamName' --output text)
          if [ -z "$LG" ] || [ "$LG" = "None" ] || [ -z "$LS" ] || [ "$LS" = "None" ]; then
            echo "No CloudWatch Logs attached to this build. Raw build JSON:"
            aws codebuild batch-get-builds --region "$REG" --ids "$BID" --output json || true
            exit 0
          fi
          echo "--- LOG HEAD (100) ---"
          aws logs get-log-events --region "$REG" --log-group-name "$LG" --log-stream-name "$LS" --limit 100 --output text | sed -E 's/^.*\t//'
          echo "--- LOG TAIL (100) ---"
          aws logs get-log-events --region "$REG" --log-group-name "$LG" --log-stream-name "$LS" --limit 10000 --output text | sed -E 's/^.*\t//' | tail -n 100

      # ---------- PREFLIGHT: Nodegroup ----------
      - name: Preflight - heal/delete stuck Nodegroup stack
        run: |
          set -euo pipefail
          STACK="${NG_STACK}"
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")
          echo "Nodegroup stack status: $STATUS"
          if [[ "$STATUS" == "ROLLBACK_FAILED" || "$STATUS" == "ROLLBACK_COMPLETE" || "$STATUS" == "DELETE_FAILED" ]]; then
            aws cloudformation delete-stack --stack-name "$STACK" || true
            if ! aws cloudformation wait stack-delete-complete --stack-name "$STACK"; then
              mapfile -t FAILS < <(
                aws cloudformation describe-stack-events --stack-name "$STACK" --max-items 200 \
                  --query "reverse(StackEvents)[?contains(ResourceStatus,'DELETE_FAILED')].[LogicalResourceId]" \
                  --output text | awk '!seen[$0]++'
              )
              [[ ${#FAILS[@]} -gt 0 ]] && aws cloudformation delete-stack --stack-name "$STACK" --retain-resources ${FAILS[*]} || true
              aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
            fi
          fi

      - name: Create/Update node group
        run: |
          PARAMS=$(jq -r '.Parameters | to_entries[] | "\(.key)=\(.value)"' cloudformation/parameters/${ENV}/nodegroup.json)
          aws cloudformation deploy \
            --template-file cloudformation/nodegroup.yaml \
            --stack-name "${NG_STACK}" \
            --parameter-overrides $PARAMS PublicSubnetIds="${{ steps.vpc.outputs.public_subnets }}" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      # ---------- Failure event dumps (helpful on error) ----------
      - name: Show EKS stack failure events (if any)
        if: failure()
        run: |
          aws cloudformation describe-stack-events --stack-name "${EKS_STACK}" \
            --max-items 40 \
            --query "StackEvents[?ends_with(ResourceStatus,'FAILED')].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
            --output table

      - name: Show Nodegroup stack failure events (if any)
        if: failure()
        run: |
          aws cloudformation describe-stack-events --stack-name "${NG_STACK}" \
            --max-items 40 \
            --query "StackEvents[?ends_with(ResourceStatus,'FAILED')].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
            --output table